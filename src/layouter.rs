//! This is the base tag type, which is generated by the wasm,
//! layouted, and passed to the renderer.
//! It's serialized by serde/bincode.
//! The size of enums is 4 bytes for the option + the size of
//! any additional fields the specific option might have. This
//! means that different enum options might have different sizes.
//! sizeof(StyleType::Flex) != sizeof(StyleType::Inline(...))
//! Vec<Type> is 8 bytes for the size followed by size * sizeof(Type).;

use std::rc::Rc;

use serde::{Deserialize, Serialize};

pub type LayoutResult<T> = Result<T, LayoutErr>;

pub enum LayoutErr {
    NotYetImplemented,
    Negativef32,
    TextTagHasChildren,
    TextSplittingError,
}

/// RGBA
pub type Color = [u8; 4];

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub struct Tag {
    pub style_type: StyleType,
    pub style: Style,
    pub children: Vec<Tag>,
    pub width: Option<f32>,
    pub height: Option<f32>,
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub struct TagOptions {
    pub width: Option<f32>,
    pub height: Option<f32>,
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub enum StyleType {
    Text(String),
    // TODO: Implement: Flex(FlexDirection),
    Inline(FlowHorizontal, FlowVertical),
    // TODO: Table {
    // size_method: TableSizeMethod,
    // columns: u32,
    // rows: u32,
    // },
    Newline,
}

impl StyleType {
    fn to_layout_type(self) -> LayoutType {
        match self {
            Self::Text(t) => LayoutType::Text(t),
            _ => LayoutType::Box,
        }
    }
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub enum FlexDirection {
    Row,
    RowReverse,
    Column,
    ColumnReverse,
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub enum TableSizeMethod {
    Auto,
    Fixed,
}

/// This is style information apparent on any tag
#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub struct Style {
    pub border_radius: f32,
    pub stroke_width: f32,
    pub fill_color: Color,
    pub outline_color: Color,
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub enum FlowHorizontal {
    LeftToRight,
    RightToLeft,
}

#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub enum FlowVertical {
    TopToBottom,
    BottomToTop,
}

/// This does not contain a reference to the tag tree, because it needs to be serialized later for painting
#[derive(Deserialize, Serialize, PartialEq, Debug)]
pub struct LayoutBox {
    pub dimensions: Dimensions,
    pub layout_type: LayoutType,
    pub style: Style,
    pub children: Vec<LayoutBox>,
}

impl LayoutBox {
    fn layout_pos(self) -> LayoutResult<LayoutBox> {
        todo!()
    }
}

/// This will later store the border sizes too, with the [`EdgeSizes`] struct
#[derive(Deserialize, Serialize, Clone, Copy, Debug, PartialEq, Default)]
pub struct Dimensions {
    pub content: Rect,
}

#[derive(Deserialize, Serialize, Clone, Copy, Debug, PartialEq, Default)]
pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}

impl Rect {
    pub fn with_inset(self, val: f32) -> Rect {
        Rect {
            x: (self.x + val).floor() + 0.5,
            y: (self.y + val).floor() + 0.5,
            width: (self.width - val - val).floor(),
            height: (self.height - val - val).floor(),
        }
    }

    fn expanded_by(self, edge: EdgeSizes) -> Rect {
        Rect {
            x: self.x - edge.left,
            y: self.y - edge.top,
            width: self.width + edge.left + edge.right,
            height: self.height + edge.top + edge.bottom,
        }
    }

    pub fn contains(self, x: f32, y: f32) -> bool {
        self.x <= x && self.x + self.width >= x && self.y <= y && self.y + self.height > y
    }
}

#[derive(Deserialize, Serialize, Clone, Copy, Debug, PartialEq, Default)]
pub struct EdgeSizes {
    pub left: f32,
    pub right: f32,
    pub top: f32,
    pub bottom: f32,
}

#[derive(Deserialize, Serialize, PartialEq, Clone, Debug)]
pub enum LayoutType {
    Box,
    Text(String),
}

/// All of this is information about the parent of a tag
#[allow(dead_code)]
#[derive(Debug)]
struct ParentInfo<'a> {
    pub x: f32,
    pub y: f32,
    pub z: u32,
    pub width: f32,
    pub height: f32,
    /// This is here because sometimes you need to go up the
    /// tree to get something like the maximum width
    pub next_parent: Option<&'a ParentInfo<'a>>,
}

impl<'a> ParentInfo<'a> {
    fn default_with_parent(next_parent: &'a ParentInfo) -> ParentInfo<'a> {
        ParentInfo {
            x: 0f32,
            y: 0f32,
            z: 0,
            width: 0f32,
            height: 0f32,
            next_parent: Some(next_parent),
        }
    }
    fn max_width(&self) -> f32 {
        if self.width != 0f32 {
            self.width
        } else if let Some(next_parent) = self.next_parent {
            next_parent.max_width()
        } else {
            // This shouldn't really happen
            panic!("No maximum height found, this shouldn't happen because the highest ParentInfo element should contain the viewport size");
        }
    }

    fn max_height(&self) -> f32 {
        if self.height != 0f32 {
            self.height
        } else if let Some(next_parent) = self.next_parent {
            next_parent.max_height()
        } else {
            panic!("No maximum height found, this shouldn't happen because the highest ParentInfo element should contain the viewport size")
        }
    }
}

impl Tag {
    pub fn layout(self, width: f32, height: f32) -> LayoutResult<LayoutBox> {
        let parent = ParentInfo {
            x: 0f32,
            y: 0f32,
            z: 0,
            width: width,
            height: height,
            next_parent: None,
        };
        let layout_box = self.calculate_dimensions(&parent)?;
        layout_box.layout_pos()
    }

    /// This function is called recursively.
    /// What this does is call the calculate_dimensions function on all it's
    /// children, and then figure out how to layout all of them.
    /// If size or width isn't specified, it's inferred either
    /// by looking at the size of call the children, or by getting
    /// a specified size assigned by it's parent
    fn calculate_dimensions(self, parent_info: &ParentInfo) -> LayoutResult<LayoutBox> {
        match self.style_type {
            StyleType::Text(mut t) => {
                let mut width = 0f32;
                let mut height = 0f32;
                if !self.children.is_empty() {
                    return Err(LayoutErr::TextTagHasChildren);
                }
                // 0.0 in parent_info.width means that there is no width provided
                if parent_info.width != 0.0 {
                    let mut new_text = String::new();
                    // If necessary, split into multiple lines
                    let mut all = vec![];
                    for line in t.lines() {
                        let mut lines = vec![];
                        split_after_width(&mut lines, line, parent_info.width);
                        all.append(&mut lines);
                    }
                    for line in all {
                        let (line_x, line_y) = get_text_dimensions(line);
                        if width < line_x {
                            width = line_x;
                        }
                        height += line_y;
                        new_text.push_str(format!("{}\n", line).as_str());
                    }
                    t = new_text;
                } else {
                    (width, height) = get_text_dimensions(&t);
                }

                Ok(LayoutBox {
                    dimensions: Dimensions {
                        content: Rect {
                            x: 0f32, // These are calculated at a later step
                            y: 0f32,
                            width,
                            height,
                        },
                    },
                    layout_type: LayoutType::Text(t),
                    style: self.style,
                    children: vec![],
                })
            }
            StyleType::Newline => {
                let mut new_children = Vec::with_capacity(self.children.len());
                let mut this_info = ParentInfo::default_with_parent(&parent_info);
                for child in self.children {
                    let child = child.calculate_dimensions(&this_info)?;
                    if this_info.width < child.dimensions.content.width {
                        this_info.width = child.dimensions.content.width;
                    }
                    this_info.height = child.dimensions.content.height + this_info.height;
                    new_children.push(child);
                }
                Ok(LayoutBox {
                    dimensions: Dimensions {
                        content: Rect {
                            x: 0.0,
                            y: 0.0,
                            width: this_info.width,
                            height: this_info.height,
                        },
                    },
                    layout_type: LayoutType::Box,
                    style: self.style,
                    children: new_children,
                })
            }
            StyleType::Inline(_, _) => {
                let max_width = self.width.unwrap_or_else(|| parent_info.max_width());
                let max_height = self.height.unwrap_or_else(|| parent_info.max_height());
                let mut this_info = ParentInfo {
                    x: 0f32,
                    y: 0f32,
                    z: 0,
                    width: max_width,
                    height: max_height,
                    next_parent: Some(&parent_info),
                };
                // The width still remaining in the current line
                let mut remaining_line_width = max_width;

                // This should be used later for when we implement vertical-first flow
                // let mut remaining_col_height = max_height;

                let mut new_children: Vec<LayoutBox> = Vec::with_capacity(self.children.len());

                // It should be noted there that we don't actually care if this goes beyond the max_height
                // And, this could be used to easily get the position of the children, but that's done
                // at a later step (probably). We could make it so some parts complete here and others
                // complete at the layout step later?
                for child in self.children {
                    let child = child.calculate_dimensions(&this_info)?;
                    if child.dimensions.content.width > remaining_line_width {
                        // Put child in next line
                        remaining_line_width = max_width;
                    } else {
                        // Child fits in current line
                        remaining_line_width -= child.dimensions.content.width;
                    }
                    new_children.push(child);
                }
                Ok(LayoutBox {
                    dimensions: Dimensions {
                        content: Rect {
                            x: 0f32,
                            y: 0f32,
                            width: max_width,
                            height: max_height,
                        },
                    },
                    layout_type: LayoutType::Box,
                    style: self.style,
                    children: new_children,
                })
            }
        }
        // Err(LayoutErr::NotYetImplemented)
    }
}

fn split_after_width<'a>(vec: &mut Vec<&'a str>, line: &'a str, width: f32) -> LayoutResult<()> {
    let x = get_text_width(line);
    if x > width {
        // Split into (one, two), push one to vec
        let (one, two) = split(line.as_ref(), width)?;
        vec.push(one);
        split_after_width(vec, two, width)?;
    } else {
        vec.push(line);
    }
    Ok(())
}

fn split<'a>(line: &'a str, split_pos: f32) -> LayoutResult<(&str, &str)> {
    let mut running_width = 0.01;
    let mut one_width = 0;
    let iter = line.char_indices();
    for (pos, _char) in iter {
        running_width += 6.0; // TODO: change this to actual width of chars
        if running_width > split_pos {
            return if split_pos == 0.0 {
                Err(LayoutErr::TextSplittingError)
            } else {
                Ok((&line[..pos], &line[pos..]))
            };
        } else {
            one_width = pos;
        }
    }
    Ok((&line[..one_width], ""))
}

/// TODO:/FIXME: Calculate actual font size for accurate layouting,
/// using an actual font and information about how to render the text.
/// This should be text size, font family, and others, but shouldn't be
/// stuff like boldness, as that's going to be done using markdown (probably)
fn get_text_dimensions(s: impl AsRef<str>) -> (f32, f32) {
    // This is not based on anything
    let w = get_text_width(s);
    let h = 16.0;
    (w, h)
}

fn get_text_width(s: impl AsRef<str>) -> f32 {
    s.as_ref().chars().count() as f32 * 6.0
}
